import json as pyjson
from datetime import datetime

values = [
    ('all_fluids_verbose.json','../src/Fluids/all_fluids_JSON.h','all_fluids_JSON'),
    ('mixtures/mixture_excess_term.json', '../src/Backends/mixture_excess_term_JSON.h', 'mixture_excess_term_JSON'),
    ('mixtures/mixture_reducing_parameters.json', '../src/Backends/mixture_reducing_parameters_JSON.h', 'mixture_reducing_parameters_JSON')
]

for infile,outfile,variable in values:
    # Check you haven't messed up the JSON file and it will still load
    pyjson.loads(open(infile,'r').read())
    
    # see another idea:
    # http://stackoverflow.com/questions/7366391/embedding-a-text-file-in-an-exe-which-can-be-accessed-using-fopen
    
    json = open(infile,'r').read()
    
    # Escape all existing quotations
    json = json.replace('"','\\"')
    
    # Split into lines
    json = json.split('\n')
    
    # Add " to beginning and end of every line and end line with comma
    for i,line in enumerate(json):
        json[i] = '"'+line+'",'
    
    # Back together
    json = '\n'.join(json)
    
    # Generate the output string
    output  = '// File generated by the script dev/JSON_to_C++.py on '+ str(datetime.now()) + '\n\n'
    output += '// C array of std::string lines\n'
    output += 'std::string '+variable+'_c_lines[] = {"",\n' + json + '};'+'\n\n'
    output += '// Combined into a single std::string \nstd::vector<std::string> '+variable+'_lines('+variable+'_c_lines, '+variable+'_c_lines + sizeof('+variable+'_c_lines) / sizeof(std::string)); \n\n'
    output += 'std::string '+variable+' = strjoin('+variable+'_lines,"");'
    
    f = open(outfile,'w')
    f.write(output)
    f.close()
